<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-08-01T08:07:05-07:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JeongUk Jang</title><subtitle>Github Pages template for academic personal websites, forked from mmistakes/minimal-mistakes</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><entry><title type="html">수학적 귀납법</title><link href="http://localhost:4000/posts/2020/08/05/mathematical_induction" rel="alternate" type="text/html" title="수학적 귀납법" /><published>2020-08-05T00:00:00-07:00</published><updated>2020-08-05T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/08/05/mathematical_induction</id><content type="html" xml:base="http://localhost:4000/posts/2020/08/05/mathematical_induction">&lt;h2 id=&quot;수열의-귀납적-정의&quot;&gt;수열의 귀납적 정의&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;수열의 일부분을 알려준다. 이 이웃하는 항들의 관계로 수열을 정의하는 것&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등차수열의-귀납적-정의&quot;&gt;등차수열의 귀납적 정의&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+1}-a_n=d$인 수열을 본다면 “공차가 $d$인 등차수열”이라는 것을 알아야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+1}=a_n+d$도 마찬가지다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+1}-a_n=a_{n+2}-a_{n-1}$의 경우에도 등차수열임을 알 수 있다. 다만, 이 경우에는 공차가 얼마인지는 알 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$2a_{n+1}=a_n+a_{n+2}$인 경우에도 $a_{n+1}$이 등차중항이므로 등차수열임을 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등비수열의-귀납적-정의&quot;&gt;등비수열의 귀납적 정의&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;${a_{n+1}\over a_n}=r$인 수열을 본다면 “공비가 $r$인 등비수열”이라는 것을 알아야 한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+1}=ra_n$도 마찬가지다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;${a_{n+1}\over a_n}={a_{n+2}\over a_{n+1}}$의 경우에도 등비수열임을 알 수 있다. 다만, 이 경우에는 공비가 얼마인지는 알 수 없다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+1}^2=a_na_{n+2}$인 경우에도 $a_{n+1}$이 등비중항이므로 등비수열임을 나타낸다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;수학적-귀납법&quot;&gt;수학적 귀납법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;모든 자연수에 대해 명제 $p(n)$이 성립함을 증명할 때 사용하는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 자연수에 대해 명제가 성립하는지 실제로 보여주는 방법은 효율적이지 않다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이웃하는 두 항의 관계를 고려한다. 즉, $k$번째 항에서 명제 $p(n)$이 성립한다고 가정한다. 이것이 $k+1$번째 항에서도 보인다. 그리고 첫 번째 항이 되는지 확인한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;첫 번째 항이 맞고, $k, k+1$번째 항도 맞으면 모든 자연수에 대해 맞는 것이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;실제 문제에서는 $n\ge2$ 혹은 $n\ge3$ 등의 조건이 있을 수 있는데 이럴 때는 첫째 항을 2 혹은 3으로 잡아주면 된다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">수열의 귀납적 정의 수열의 일부분을 알려준다. 이 이웃하는 항들의 관계로 수열을 정의하는 것</summary></entry><entry><title type="html">수열의 합</title><link href="http://localhost:4000/posts/2020/08/04/sigma" rel="alternate" type="text/html" title="수열의 합" /><published>2020-08-04T00:00:00-07:00</published><updated>2020-08-04T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/08/04/sigma</id><content type="html" xml:base="http://localhost:4000/posts/2020/08/04/sigma">&lt;h2 id=&quot;합의-기호&quot;&gt;합의 기호&lt;/h2&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\sum_{i=1}^na_k=S_n&lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;시작이 꼭 1일 필요가 없다.
    &lt;ul&gt;
      &lt;li&gt;$\sum_{i=m}^na_k$과 같이 할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;합의-기호-sum의-성질&quot;&gt;합의 기호 $\sum$의 성질&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;실수배, +, -에 대해 자유롭다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\sum_{i=1}^nca_k=c(a_1+a_2+…+a_n)=c\sum_{i=1}^na_k$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\sum_{i=1}^n(a_k+b_k)=(a_1+b_1)+(a_2+b_2)+…+(a_n+b_n)=(a_1+a_2+…+a_n)+(b_1+b_2+…+b_n)=\sum_{i=1}^na_k+\sum_{i=1}^nb_k$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\sum_{i=1}^n(a_k-b_k)=\sum_{i=1}^na_k-\sum_{i=1}^nb_k$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\sum_{i=1}^nc=nc$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;곱셈, 나눗셈에 대해서는 자유롭지 않다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;자연수의-거듭제곱의-합&quot;&gt;자연수의 거듭제곱의 합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;$\sum_{i=1}^ni={n(n+1)\over 2}$&lt;/li&gt;
  &lt;li&gt;$\sum_{i=1}^ni^2={n(n+1)(2n+1)\over 6}$&lt;/li&gt;
  &lt;li&gt;$\sum_{i=1}^ni^3=({n(n+1)\over 2})^2$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;여러가지-수열의-합&quot;&gt;여러가지 수열의 합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;${a\over AB}={a\over B-A}({1\over A}-{1\over B})$
    &lt;ul&gt;
      &lt;li&gt;$\sum_{k=1}^{10}{1\over k(k+1)}=\sum_{k=1}^{10}({1\over k}-{1\over k+1})$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;무리식의 합이 계산이 바로 안될 때는 주로 근호가 문제가 된다. 근호를 유리화하면 문제를 쉽게 해결할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">합의 기호</summary></entry><entry><title type="html">등차수열, 등비수열</title><link href="http://localhost:4000/posts/2020/08/03/deungcha_deungbi" rel="alternate" type="text/html" title="등차수열, 등비수열" /><published>2020-08-03T00:00:00-07:00</published><updated>2020-08-03T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/08/03/deungcha_deungbi</id><content type="html" xml:base="http://localhost:4000/posts/2020/08/03/deungcha_deungbi">&lt;h2 id=&quot;등차수열&quot;&gt;등차수열&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;첫째항부터 차례로 일정한 수를 더하여 얻은 수열&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;첫째항, 둘째항, 셋째항, …의 차가 모두 같다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ex. 1,3,5,7,9&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1, a_2, a_3, …$로 표현&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;등차수열에서 가장 중요한 것은 &lt;strong&gt;공차(d)&lt;/strong&gt;(정의에 나온 일정한 수, 예제에서는 2가 공차)
    &lt;ul&gt;
      &lt;li&gt;$d=a_{n+1}-a_n$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;일반항($a_n$)=$a_1+(n-1)d$
    &lt;ul&gt;
      &lt;li&gt;$a_1=1$&lt;/li&gt;
      &lt;li&gt;$a_2=1+d$&lt;/li&gt;
      &lt;li&gt;$a_3=1+2d$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;등차중항($x$) : 세 수 $a,x,b$가 등차수열일 때, $x$를 등차중항이라고 한다.
    &lt;ul&gt;
      &lt;li&gt;$x={a+b\over 2}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등차수열의-특징&quot;&gt;등차수열의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+k}-a_n=kd$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_{n+k}=a_n+kd$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1+a_7=a_2+a_6=a_3+a_5=2a_4$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1+a_6=a_2+a_5=a_3+a_4$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등차수열의-합&quot;&gt;등차수열의 합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1, a_2, …, a_n$은 등차수열&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$S_n=a_1+a_2+…+a_n=?$&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;$S_n=a_1+a_2+…+a_n$&lt;/li&gt;
      &lt;li&gt;$S_n=a_n+a_{n-1}+…+a_1$&lt;/li&gt;
      &lt;li&gt;$2S_n=(a_1+a_n)+(a_2+a_{n-1})+…+(a_n+a_1)$&lt;/li&gt;
      &lt;li&gt;$2S_n=n(a_1+a_n)$&lt;/li&gt;
      &lt;li&gt;$S_n={n(a_1+a_n)\over 2}$&lt;/li&gt;
      &lt;li&gt;첫항과 끝항을 알 때 사용할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_n=a_1+(n-1)d$를 활용하면 위 식을 다르게 전개할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;$S_n={n(2a_1+(n-1)d)\over 2}$
    &lt;ul&gt;
      &lt;li&gt;첫항과 공차를 알 때 사용할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$a_m+a_{m+1}+…+a_n={(m+n-1)(a_m+a_n)\over 2}$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등비수열&quot;&gt;등비수열&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;첫째항부터 차례로 일정한 수를 곱하여 얻은 수열&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;등비수열에서 중요한 것은 &lt;strong&gt;공비($r$)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;$r={a_{n+1}\over a_n}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일반항($a_n$)=$ar^{n-1}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;등비중항($x$) : 세 수 $a,x,b$가 등비수열일 때, $x$를 등비중항이라고 한다.
    &lt;ul&gt;
      &lt;li&gt;$x=\sqrt{ab}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등비수열의-특징&quot;&gt;등비수열의 특징&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;${a_{n+k}\over a_n}={a_1r^{n+k-1}\over a_1r^{n-1}}=r^{n+k-1-(n-1)}=r^k$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;${a_{n+k}}=a_nr^k$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1a_7=a_2a_6=a_3a_5=a_4^2$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1a_6=a_2a_5=a_3a_4$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;등비수열의-합&quot;&gt;등비수열의 합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$a_1, a_2, …, a_n$은 등비수열&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$S_n=a_1+a_2+…+a_n=?$&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;$S_n=a_1+a_2+…+a_n$&lt;/li&gt;
      &lt;li&gt;$rS_n=a_2+a_3+…+a_{n+1}$&lt;/li&gt;
      &lt;li&gt;$(1-r)S_n=a_1-a_{n+1}$&lt;/li&gt;
      &lt;li&gt;$S_n={a_1-a_{n+1}\over (1-r)}={a_1(1-r^n)\over (1-r)}={a_1(r^n-1)\over (r-1)}(r\neq 0)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$r=1$인 경우 $S_n=na_1$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$a_m+a_{m+1}+…+a_n={a_m(1-r^{n-m+1})\over 1-r}(r\neq 0)$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">등차수열 첫째항부터 차례로 일정한 수를 더하여 얻은 수열</summary></entry><entry><title type="html">무리함수(Irrational Function)</title><link href="http://localhost:4000/posts/2020/08/02/irrational_function" rel="alternate" type="text/html" title="무리함수(Irrational Function)" /><published>2020-08-02T00:00:00-07:00</published><updated>2020-08-02T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/08/02/irrational_function</id><content type="html" xml:base="http://localhost:4000/posts/2020/08/02/irrational_function">&lt;h2 id=&quot;무리함수&quot;&gt;무리함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;무리수 : 분수로 나타낼 수 없는 수
    &lt;ul&gt;
      &lt;li&gt;$\sqrt{2}, \sqrt{3}, \pi$&lt;/li&gt;
      &lt;li&gt;$\pi$와 같은 특수한 수를 제외하고는 $\sqrt{}$가 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;무리식 : 근호 안에 문자가 포함된 식 중 유리식이 아닌 것(&lt;strong&gt;근호 안에 있는 것은 0보다 크거나 같다.&lt;/strong&gt;)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;무리함수 : $y=f(x)$, $f(x)$는 $x$에 관한 무리식이다.(&lt;strong&gt;근호 안에 있는 것은 0보다 크거나 같다.&lt;/strong&gt;)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ysqrtaxa0-xge-0&quot;&gt;$y=\sqrt{ax}(a&amp;gt;0, x\ge 0)$&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/89093644-3d79d980-d3f7-11ea-8783-39c4a17ad189.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;무리함수의 정의역은 근호 안을 보면 알 수 있다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;근호 안은 0크거나 같아야 한다.&lt;/li&gt;
      &lt;li&gt;$a&amp;gt;0$이면 $x\ge 0$이 정의역이 된다.&lt;/li&gt;
      &lt;li&gt;$a&amp;lt;0$이면 $x\le 0$이 정의역이 된다.&lt;/li&gt;
      &lt;li&gt;이 경우는 $a&amp;gt;0$이므로, 정의역은 $x\ge 0$이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$y={1\over a}x^2(a&amp;gt;0,x\ge 0)$의 역함수이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;위 그래프는 $a=2$를 넣어 그린 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;즉, 이들의 관계는 다음과 같다.
    &lt;ol&gt;
      &lt;li&gt;역함수&lt;/li&gt;
      &lt;li&gt;$y=x$를 기준으로 대칭&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ysqrtax-y-sqrtaxaneq-0&quot;&gt;$y=\sqrt{ax}, y=-\sqrt{ax}(a\neq 0)$&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/89093646-3eab0680-d3f7-11ea-8b2d-669854408622.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;두 함수는 $a&amp;gt;0$, $a&amp;lt;0$으로 나눠볼 수 있다. 즉 총 네 개의 그래프가 나오며, 각각은 사분면을 하나씩 차지한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;모든 그래프는 원점을 지난다.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;4사분면에 있는 것은 $y=\sqrt{ax}(a&amp;gt;0, x\ge 0)$를 x축 대칭한 것($y$에 $-y$ 대입)&lt;/li&gt;
      &lt;li&gt;2사분면에 있는 것은 $y=\sqrt{ax}(a&amp;gt;0, x\ge 0)$를 y축 대칭한 것($x$에 $-x$ 대입)&lt;/li&gt;
      &lt;li&gt;3사분면에 있는 것은 $y=\sqrt{ax}(a&amp;gt;0, x\ge 0)$를 원점 대칭한 것($x$에 $-x$, $y$에 $-y$ 대입)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;그래프의 모양을 생각해보면 정의역과 치역을 쉽게 구할 수 있다.
    &lt;ul&gt;
      &lt;li&gt;1사분면($y=\sqrt{ax}(a&amp;gt;0, x\ge 0)$)
        &lt;ul&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;정의역 : $\{x&lt;/td&gt;
                  &lt;td&gt;x\ge 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;치역 : $\{y&lt;/td&gt;
                  &lt;td&gt;y\ge 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4사분면($y=\sqrt{ax}(a&amp;gt;0, x\ge 0)$)
        &lt;ul&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;정의역 : $\{x&lt;/td&gt;
                  &lt;td&gt;x\ge 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;치역 : $\{y&lt;/td&gt;
                  &lt;td&gt;y\le 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;2사분면($y=\sqrt{ax}(a&amp;lt;0, x\le 0)$)
        &lt;ul&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;정의역 : $\{x&lt;/td&gt;
                  &lt;td&gt;x\le 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;치역 : $\{y&lt;/td&gt;
                  &lt;td&gt;y\ge 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;4사분면($y=\sqrt{ax}(a&amp;lt;0, x\le 0)$)
        &lt;ul&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;정의역 : $\{x&lt;/td&gt;
                  &lt;td&gt;x\le 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;table&gt;
              &lt;tbody&gt;
                &lt;tr&gt;
                  &lt;td&gt;치역 : $\{y&lt;/td&gt;
                  &lt;td&gt;y\le 0\}$&lt;/td&gt;
                &lt;/tr&gt;
              &lt;/tbody&gt;
            &lt;/table&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;근호는 반드시 양수이기 때문에 치역은 근호 앞의 부호가 결정한다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;부호가 +이면 치역은 $\{y&lt;/td&gt;
              &lt;td&gt;y\ge 0\}$&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;부호가 -이면 치역은 $\{y&lt;/td&gt;
              &lt;td&gt;y\le 0\}$&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ysqrtax-pq-y-sqrtax-pqaneq-0&quot;&gt;$y=\sqrt{a(x-p)}+q, y=-\sqrt{a(x-p)}+q(a\neq 0)$&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/89093647-3f439d00-d3f7-11ea-8f20-d2910fb75482.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$y=\sqrt{ax}, y=-\sqrt{ax}(a\neq 0)$을 $x$축으로 $p$만큼, $y$축으로 $q$만큼 평행 이동시킨 것이다.($x$에 $x-p$ 대입, $y$에 $y-q$ 대입)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정의역과 치역도 그에 맞게 변경시키면 된다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;무리함수들 또한 유리함수와 역함수 관계를 가진다는 것을 기억해야 한다.&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">무리함수 무리수 : 분수로 나타낼 수 없는 수 $\sqrt{2}, \sqrt{3}, \pi$ $\pi$와 같은 특수한 수를 제외하고는 $\sqrt{}$가 있다.</summary></entry><entry><title type="html">유리함수(Rational Function)</title><link href="http://localhost:4000/posts/2020/08/01/rational_function" rel="alternate" type="text/html" title="유리함수(Rational Function)" /><published>2020-08-01T00:00:00-07:00</published><updated>2020-08-01T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/08/01/rational_function</id><content type="html" xml:base="http://localhost:4000/posts/2020/08/01/rational_function">&lt;h2 id=&quot;평행이동&quot;&gt;평행이동&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;점이나 도형을 일정한 거리만큼 움직이는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;점의 평행이동과 도형의 평행이동은 다르다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;점의 평행이동 : $p(a,b)$을 $x$축으로 $p$만큼, $y$축으로 $q$만큼 이동시키면 $p’(a+p, b+q)$가 된다.&lt;/li&gt;
      &lt;li&gt;도형의 평행이동 : (도형은 $x, y$의 식으로 나타낸다) $f(x,y)=0$을 $x$축으로 $p$만큼, $y$축으로 $q$만큼 이동시키면 $f’(x-p, y-q)=0$이 된다. 즉, 도형의 대칭이동은 $x$에 $x-p$를 대입하고, $y$에 $y-q$를 대입한 것이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;대칭이동&quot;&gt;대칭이동&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;점과 도형이 똑같음&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;$x$축 대칭 : $(a,b)\rightarrow(a,-b)$ 즉, $y$ 대신 $-y$ 대입&lt;/li&gt;
  &lt;li&gt;$y$축 대칭 : $(a,b)\rightarrow(-a,b)$ 즉, $x$ 대신 $-x$ 대입&lt;/li&gt;
  &lt;li&gt;원점 대칭 : $(a,b)\rightarrow(-a,-b)$ 즉, $x$ 대신 $-x$ 대입, $y$ 대신 $-y$ 대입&lt;/li&gt;
  &lt;li&gt;$y=x$에 대하여 대칭 : $(a,b)\rightarrow(b,a)$ 즉, $x$ 대신 $y$ 대입, $y$ 대신 $x$ 대입(역함수에서 자주 등장)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;유리함수&quot;&gt;유리함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;유리수 : 분수로 나타낼 수 있는 수&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;유리식 : 분수로 나타낼 수 있는 식
    &lt;ul&gt;
      &lt;li&gt;${A\over B}$의 꼴($A, B$는 다항식, $B\neq 0$)&lt;/li&gt;
      &lt;li&gt;ex. ${x^2+2x+1\over 2x+1}$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유리함수 : $y=f(x)$에서 $f(x)$가 $x$에 대한 유리식(분모$\neq0$)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ykover-xkneq-0&quot;&gt;$y={k\over x}(k\neq 0)$&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;유리함수의 하나&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;$k&amp;gt;0$
    &lt;ul&gt;
      &lt;li&gt;1, 3사분면에 존재&lt;/li&gt;
      &lt;li&gt;$k$의 값이 커질수록 원점에서 멀어진다.
  &lt;img src=&quot;https://user-images.githubusercontent.com/26649034/89045472-8b0a2e00-d386-11ea-97e4-7b2a65dd919b.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$k&amp;lt;0$
    &lt;ul&gt;
      &lt;li&gt;2, 4사분면에 존재&lt;/li&gt;
      &lt;li&gt;$k$의 값이 커질수록 원점에서 멀어진다.
  &lt;img src=&quot;https://user-images.githubusercontent.com/26649034/89045473-8c3b5b00-d386-11ea-9f2f-a48d80e424bc.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$k&amp;gt;0$인 경우와 $k&amp;lt;0$인 경우는 $x$축, $y$축을 기준으로 대칭이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정의역 : $\{x|x\neq0인\;모든\;실수\}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;치역 : $\{y|y\neq0인\;모든\;실수\}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;대칭성 :
    &lt;ul&gt;
      &lt;li&gt;원점$(0,0)$에 대해 대칭이다.&lt;/li&gt;
      &lt;li&gt;$y=x$에 대해 대칭이다.&lt;/li&gt;
      &lt;li&gt;$y=-x$에 대해 대칭이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;점근선 : 함수의 그래프가 어떤 값에 점점 가까워지는데, 절대 만날 수는 없는 것
    &lt;ul&gt;
      &lt;li&gt;$y$축($x=0$), $x$축($y=0$)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ykover-x-pqkneq-0&quot;&gt;$y={k\over x-p}+q(k\neq 0)$&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$q$를 좌변으로 넘기면 $y-q={k\over x-p}$이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이는 $y={k\over x}$에서 $x$자리에 $x-p$를, $y$자리에 $y-q$를 넣은 것이다. 즉, $y={k\over x}$를 $x$축으로 $p$만큼, $y$축으로 $q$만큼 평행이동한 것이다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/89048816-52b91e80-d38b-11ea-921a-5e8ec7110f54.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;(위 그림은 $x$축으로 $1$만큼, $y$축으로 $2$만큼 평행이동한 것이다.)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이 경우 원점을 기준으로 대칭인 것이 아니라 $p,q$를 기준으로 대칭이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;또한 점근선은 $x=0, y=0$이 아니라 $x=p, y=q$다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정의역 : $\{x|x\neq p인\;모든\;실수\}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;치역 : $\{y|y\neq q인\;모든\;실수\}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;대칭성 :
    &lt;ul&gt;
      &lt;li&gt;$(p,q)$에 대해 대칭이다.&lt;/li&gt;
      &lt;li&gt;$y=(x-p)+q$에 대해 대칭이다.&lt;/li&gt;
      &lt;li&gt;$y=-(x-p)+q$에 대해 대칭이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;점근선 :
    &lt;ul&gt;
      &lt;li&gt;$x=p, y=q$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;유리함수는 $p, q$를 알아내는 것이 가장 중요&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">평행이동 점이나 도형을 일정한 거리만큼 움직이는 것</summary></entry><entry><title type="html">함수(Function)</title><link href="http://localhost:4000/posts/2020/07/31/function" rel="alternate" type="text/html" title="함수(Function)" /><published>2020-07-31T00:00:00-07:00</published><updated>2020-07-31T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/07/31/function</id><content type="html" xml:base="http://localhost:4000/posts/2020/07/31/function">&lt;h2 id=&quot;함수fxrightarrow-y&quot;&gt;함수($f:X\rightarrow Y$)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;대응 : $X$의 원소 $x$와 $Y$의 원소 $y$를 짝지어주는 것&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;집합 : 집합 $X$의 원소가 집합 $Y$의 원소가 &lt;strong&gt;하나씩&lt;/strong&gt; 대응되는 관계
    &lt;ul&gt;
      &lt;li&gt;함수인지 아닌지 판단하려면 $X$를 기준으로 생각하면 된다.&lt;/li&gt;
      &lt;li&gt;집합 $X$에서 대응되지 않는 원소가 있다면 함수가 아님&lt;/li&gt;
      &lt;li&gt;집합 $X$에서 두 개 이상에 대응되는 원소가 있다면 함수가 아님&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$X$ : 정의역&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$Y$ : 공역&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;치역 : 공역 중 실제로 $X$의 원소와 대응되는 것
    &lt;ul&gt;
      &lt;li&gt;치역 $\subset$ 공역&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;함숫값
    &lt;ul&gt;
      &lt;li&gt;$f(1)=a$&lt;/li&gt;
      &lt;li&gt;$f(2)=b$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서로 같은 함수($f=g$)가 되기 위한 조건
    &lt;ul&gt;
      &lt;li&gt;정의역은 정의역끼리, 공역은 공역끼리 같아야 한다.&lt;/li&gt;
      &lt;li&gt;모든 $x\in X, f(x)=g(x)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;합성함수&quot;&gt;합성함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$(g\circ f)(x)=g(f(x))$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;교환법칙이 성립하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;$g\circ f\neq f\circ g$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결합법칙이 성립한다.
    &lt;ul&gt;
      &lt;li&gt;$f\circ(g\circ h)=(f\circ g)\circ h$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;여러가지-함수&quot;&gt;여러가지 함수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;일대일 함수 : $x_1\neq x_2$이면, $f(x_1)\neq f(x_2)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;일대일 대응&lt;/strong&gt;
    &lt;ol&gt;
      &lt;li&gt;치역 = 공역&lt;/li&gt;
      &lt;li&gt;일대일 함수&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;일대일 대응은 &lt;strong&gt;역함수가 존재할 조건&lt;/strong&gt;이다.&lt;/p&gt;

    &lt;p&gt;예를 들어 보자.&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
f(x)=
  \begin{cases}
  mx+n &amp; (x&lt; a)\\
  m'x+n' &amp; (x\ge a) 
  \end{cases} %]]&gt;&lt;/script&gt;

    &lt;p&gt;1번 조건을 만족하기 위해 $mx+n=m’x+n’$을 만족해야 한다.(함수가 끊어지지 않고 연결되기 위해)&lt;/p&gt;

    &lt;p&gt;2번 조건을 만족하기 위해 $mm’&amp;gt;0$이어야 한다.(증가함수 혹은 감소함수가 되기 위해)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;상수 함수 : $f(x)=c$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;항등 함수(I)&lt;/strong&gt; : $f(x)=x$
    &lt;ul&gt;
      &lt;li&gt;$f(f(x))=x$라면 $f(x)=?$
        &lt;ul&gt;
          &lt;li&gt;$f(x)=ax+b$로 두자.&lt;/li&gt;
          &lt;li&gt;$f(f(x))=f(ax+b)=a(ax+b)+b=x$&lt;/li&gt;
          &lt;li&gt;$a^2x+ab+b=x$&lt;/li&gt;
          &lt;li&gt;$\therefore a=\pm1$&lt;/li&gt;
          &lt;li&gt;$if\;\;a=1 \rightarrow b=0$&lt;/li&gt;
          &lt;li&gt;$if\;\;a=-1\rightarrow b=any$&lt;/li&gt;
          &lt;li&gt;즉, $f(x)=x$ 또는 $f(x)=-x+k$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;역함수&quot;&gt;&lt;strong&gt;역함수&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$f:X\rightarrow Y$가 일대일 대응이어야 역함수 존재&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$f^{-1}Y\rightarrow X$&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;$x=f^{-1}(y)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;역함수의--성질&quot;&gt;역함수의  성질&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$f^{-1}(f(x))=f^{-1}(y)=x$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$f(f^{-1}(y))=f(x)=y$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;$f^{-1}\circ f=f\circ f^{-1}=I$
    &lt;ul&gt;
      &lt;li&gt;즉, 일반적인 함수는 교환법칙이 성립하지 않지만 역함수와의 합성함수는 교환법칙이 성립&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$(f^{-1})^{-1}=f$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;$(g\circ f)^{-1}=f^{-1}\circ g^{-1}$
    &lt;ul&gt;
      &lt;li&gt;$(g\circ f)(f^{-1}\circ g^{-1})=g\circ g^{-1}=I$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;역함수-구하기&quot;&gt;역함수 구하기&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;$y=f(x)$를 $x=$y에 관한 식으로 바꾼다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$x$ 대신 $y$, $y$ 대신 $x$를 대입한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;역함수의-그래프&quot;&gt;&lt;strong&gt;역함수의 그래프&lt;/strong&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;$y=f(x)$의 그래프와 $y=f^{-1}(x)$의 그래프는 직선 $y=x$에 대하여 대칭&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;주어진 구간에서 &lt;strong&gt;증가하는 함수&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;$y=f(x)$의 그래프와 $y=f^{-1}(x)$의 교점은 &lt;strong&gt;$y=x$ 위에 존재&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;그렇기 때문에 $f(x)=f^{-1}(x)$의 실근을 구하라는 문제는 다음 문제와도 같다.
        &lt;ol&gt;
          &lt;li&gt;$f(x)=x$의 실근을 구하라&lt;/li&gt;
          &lt;li&gt;$f^{-1}(x)=x$의 실근을 구하라&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주어진 구간에서 &lt;strong&gt;감소하는 함수&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;$y=f(x)$의 그래프와 $y=f^{-1}(x)$의 교점은 &lt;strong&gt;$y=x$ 또는 $y=-x+k$ 위에 존재&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;그렇기 때문에 $f(x)=f^{-1}(x)$의 실근을 구하라는 문제는 다음 문제와도 같다.
        &lt;ol&gt;
          &lt;li&gt;$f(x)=x$ 또는 $f(x)=-x+k$의 실근을 구하라&lt;/li&gt;
          &lt;li&gt;$f^{-1}(x)=x$ 또는 $f^{-1}(x)=-x+k$의 실근을 구하라&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;아래 그림은 $f(x)=-x^2+1$, $f^{-1}(x)=\sqrt{-x+1}$의 교점을 나타낸다.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/88946310-0c4fbb00-d2ca-11ea-967a-6b5efde36285.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">함수($f:X\rightarrow Y$) 대응 : $X$의 원소 $x$와 $Y$의 원소 $y$를 짝지어주는 것</summary></entry><entry><title type="html">명제(Proposition)</title><link href="http://localhost:4000/posts/2020/07/30/proposition" rel="alternate" type="text/html" title="명제(Proposition)" /><published>2020-07-30T00:00:00-07:00</published><updated>2020-07-30T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/07/30/proposition</id><content type="html" xml:base="http://localhost:4000/posts/2020/07/30/proposition">&lt;h2 id=&quot;명제와-조건&quot;&gt;명제와 조건&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;명제 : 참, 거짓을 판별할 수 있는 문장 또는 식
    &lt;ul&gt;
      &lt;li&gt;2는 홀수이다. (거짓인 명제)&lt;/li&gt;
      &lt;li&gt;3은 홀수이다. (참인 명제)&lt;/li&gt;
      &lt;li&gt;나는 잘생겼다. (명제 아님)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;조건($p$) : 미지수를 포함하는 문장 또는 식이 미지수의 값에 따라 참, 거짓이 결정되는 것
    &lt;ul&gt;
      &lt;li&gt;$x^2=4$의 경우, $x=2$일 때는 참이고, $x=3$일 때는 거짓임&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;진리집합($P$) : 조건 $p$를 참이 되게 하는 모든 원소들의 집합&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;명제와-조건의-부정&quot;&gt;명제와 조건의 부정&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;$\sim p$ : $p$가 아니다.
    &lt;ul&gt;
      &lt;li&gt;집합으로 나타내면 $p^c$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$\sim(\sim p)=p$
    &lt;ul&gt;
      &lt;li&gt;집합으로 나타내면 $(p^c)^c$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;아래 목록에 있는 것들은 서로 부정이다.
    &lt;ul&gt;
      &lt;li&gt;$and\Leftrightarrow or$&lt;/li&gt;
      &lt;li&gt;$&amp;gt;\Leftrightarrow \le$&lt;/li&gt;
      &lt;li&gt;$=\Leftrightarrow \neq$&lt;/li&gt;
      &lt;li&gt;$a\le x\le b\Leftrightarrow x &amp;lt; a \;or\; x &amp;gt; b$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;prightarrow-q의-참-거짓&quot;&gt;$p\rightarrow q$의 참, 거짓&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;조건 두 개를 합치면 명제가 된다.($p\rightarrow q$)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$P\subset Q$&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;$x=2$이면 $x^2=4$이다.&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;이 명제가 참이 되기 위해서는 $p$의 진리집합이 $q$의 진리집합의 부분집합이어야 한다.&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;$p$의 진리집합은 $\{2\}$이고, $q$의 진리집합은 $\{2,-2\}$이다.&lt;/li&gt;
      &lt;li&gt;그러므로 이 명제는 참인 명제이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$p$를 “가정”이라고 하고, $q$를 “결론”이라고 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;필요조건-충분조건&quot;&gt;필요조건, 충분조건&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;“$p$이면 $q$이다.”가 참인 명제라면 화살표 두 개를 사용해서 $p\Rightarrow q$라고 표현한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$P\subset Q$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;이 때 $p$를 &lt;strong&gt;충분조건&lt;/strong&gt;, $q$를 &lt;strong&gt;필요조건&lt;/strong&gt;이라고 한다.
    &lt;ul&gt;
      &lt;li&gt;“$p$는 조건이 충분해서 조건이 필요한 $q$에게 나눠준다.”라고 외우기&lt;/li&gt;
      &lt;li&gt;예를 들어, “6의 배수이면 2의 배수이다.”라는 명제를 생각해보자. 6의 배수는 “2의 배수 &amp;amp; 3의 배수”라는 두 조건을 만족시켜야 하며, 2의 배수는 “2의 배수”만 만족시키면 된다. 6의 배수의 조건이 더 까다로우므로(충분하므로) 6의 배수가 충분조건이 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$p$의 진리집합은 $q$의 진리집합의 부분집합이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;필요충분조건
    &lt;ul&gt;
      &lt;li&gt;$p\Leftrightarrow q$&lt;/li&gt;
      &lt;li&gt;$P=Q$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;명제는 집합으로 포함할 수 있다. 그래서 $p\rightarrow q$라는 명제를 아래와 같은 집합으로 표현하기도 한다.
    &lt;ol&gt;
      &lt;li&gt;$A\cap B=A$&lt;/li&gt;
      &lt;li&gt;$A\cup B=B$&lt;/li&gt;
      &lt;li&gt;$A-B=\emptyset$&lt;/li&gt;
      &lt;li&gt;$A\cup B^c=\emptyset$&lt;/li&gt;
      &lt;li&gt;$A^c\supset B^c$&lt;/li&gt;
      &lt;li&gt;$A^c\cup B=U$&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;모든-또는-어떤을-포함한-명제&quot;&gt;‘모든’ 또는 ‘어떤’을 포함한 명제&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;모든&lt;/strong&gt; $x$에 대하여 $p$이다.
    &lt;ul&gt;
      &lt;li&gt;$p$의 진리집합과 모든 $x$, 즉 $U$가 같으면 참이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;어떤&lt;/strong&gt; $x$에 대하여 $p$이다.
    &lt;ul&gt;
      &lt;li&gt;$p$의 진리집합이 하나라도 있으면 참이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;‘모든’과 ‘어떤’은 서로 부정이다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;역과-대우&quot;&gt;역과 대우&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;역 : 가정과 결론을 바꾸는 것
    &lt;ul&gt;
      &lt;li&gt;$p\rightarrow q$의 역은 $q\rightarrow p$이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대우 : 가정과 결론을 바꾸고 부정함
    &lt;ul&gt;
      &lt;li&gt;$p\rightarrow q$의 대우은 $\sim q\rightarrow \sim p$이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://w.namu.la/s/eaf398891d96c37b17685e9112c1cc79ce6e7362e1286f4b585c8be7c3cab2980ba072f3968cae89113d109dcafd059ea3946187571381e96a1c6874bf260d755029afd0013862b07731df955615d102a53b61daadbad33086db22fdd3f8780b&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;빨간 선은 역, 파란 선은 대우&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제로 중요한 것은 &lt;strong&gt;대우&lt;/strong&gt; 관계이다.
    &lt;ul&gt;
      &lt;li&gt;$p\rightarrow q$가 참이면 $P\subset Q$가 성립한다. 드모르간의 법칙에 의해 $Q^c\subset P^c$도 성립하며, 이는 $p\rightarrow q$의 대우 명제인 $\sim q\rightarrow \sim p$도 성립함을 나타낸다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;명제와 대우의 참, 거짓은 일치한다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;삼단논법&quot;&gt;삼단논법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;$p\Rightarrow q, q \Rightarrow r$이면 $p\Rightarrow r$이다.
    &lt;ul&gt;
      &lt;li&gt;$P\subset Q, Q\subset R$이면 $P\subset R$이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">명제와 조건 명제 : 참, 거짓을 판별할 수 있는 문장 또는 식 2는 홀수이다. (거짓인 명제) 3은 홀수이다. (참인 명제) 나는 잘생겼다. (명제 아님)</summary></entry><entry><title type="html">MLE, MAP</title><link href="http://localhost:4000/posts/2020/07/30/mle_map" rel="alternate" type="text/html" title="MLE, MAP" /><published>2020-07-30T00:00:00-07:00</published><updated>2020-07-30T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/07/30/mle_map</id><content type="html" xml:base="http://localhost:4000/posts/2020/07/30/mle_map">&lt;p&gt;MLE와 MAP는 모두 “데이터셋 $X$가 주어졌을 때 $Y$일 확률, 즉, $P(Y|X)$를 구하는 것”을 목표로 한다.&lt;/p&gt;

&lt;p&gt;이런 목표를 달성하기 위해 보통 베이즈 정리를 사용한다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\underbrace{P(Y|X)}_{\rm posterior} = \frac{\overbrace{P(X|Y)}^{\rm likelihood} \overbrace{P(Y)}^{\rm prior}}{\underbrace{P(X)}_\text{probability of seeing the data}}&lt;/script&gt;

&lt;p&gt;MAP는 위 수식을 충실히 수행한다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(Y|X)\propto P(X|Y)P(Y)&lt;/script&gt;

&lt;p&gt;반면, MLE는 &lt;strong&gt;uniform prior&lt;/strong&gt;를 가정한다. 따라서 위 수식을 아래와 같이 줄일 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(Y|X)\propto P(X|Y)&lt;/script&gt;

&lt;p&gt;따라서 MLE는 uniform prior를 가정한 MAP의 특수한 케이스다.&lt;/p&gt;

&lt;p&gt;예를 들어보자.&lt;/p&gt;

&lt;p&gt;어떤 마을에서 바닥에 떨어진 머리카락의 길이를 보고 그 머리카락이 남자의 것인지 여자의 것인지 분류하는 문제를 푼다고 하자.&lt;/p&gt;

&lt;p&gt;이 경우, $X$는 머리카락의 길이, $Y$는 성별이다.&lt;/p&gt;

&lt;p&gt;MAP의 경우 likelihood 뿐만 아니라 마을의 남녀 성비도 고려해 분류를 수행한다.&lt;/p&gt;

&lt;p&gt;반면, MLE의 경우 남녀의 성비가 동일하다고 가정하고(uniform prior), likelihood만을 고려해 분류를 수행한다.&lt;/p&gt;

&lt;h2 id=&quot;출처&quot;&gt;출처&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://darkpgmr.tistory.com/62&quot;&gt;베이즈 정리, ML과 MAP, 그리고 영상처리&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.bdhammel.com/mle-map/&quot;&gt;Maximum Likelihood Estimation and Maximum A Posterior Estimation&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">MLE와 MAP는 모두 “데이터셋 $X$가 주어졌을 때 $Y$일 확률, 즉, $P(Y|X)$를 구하는 것”을 목표로 한다.</summary></entry><entry><title type="html">집합(Set)</title><link href="http://localhost:4000/posts/2020/07/29/set" rel="alternate" type="text/html" title="집합(Set)" /><published>2020-07-29T00:00:00-07:00</published><updated>2020-07-29T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/07/29/set</id><content type="html" xml:base="http://localhost:4000/posts/2020/07/29/set">&lt;h2 id=&quot;1-정의&quot;&gt;1. 정의&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기준에 대해서 명화가게 구분할 수 있는 대상들의 모임
    &lt;ul&gt;
      &lt;li&gt;ex. 짝수의 집합, 홀수의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대문자로 나타냄
    &lt;ul&gt;
      &lt;li&gt;ex. $A$, $B$, …&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;대상 하나하나를 원소라고 함
    &lt;ul&gt;
      &lt;li&gt;소문자로 나타냄&lt;/li&gt;
      &lt;li&gt;ex. $a\in A$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-부분집합&quot;&gt;2. 부분집합&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$A\subset B$ : $A$의 모든 원소가 $B$에 포함되어 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$A=B$인 경우도 $A\subset B$이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$\emptyset$은 모든 집합의 부분집합이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$A\subset B, B\subset C \Rightarrow A\subset C$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;“$A\subset B$”를 다음과 같이 표현할 수도 있다.
    &lt;ol&gt;
      &lt;li&gt;$A\cap B=A$&lt;/li&gt;
      &lt;li&gt;$A\cup B=B$&lt;/li&gt;
      &lt;li&gt;$A-B=\emptyset$&lt;/li&gt;
      &lt;li&gt;$A\cup B^c=\emptyset\;\;$(3번과 같은 표현)&lt;/li&gt;
      &lt;li&gt;$A^c\supset B^c$&lt;/li&gt;
      &lt;li&gt;$A^c\cup B=U$&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$A=B\Leftrightarrow A\subset B, B\subset A$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;$B$의 진부분집합 $A$ : $A\subset B \And A\neq B$&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-부분집합의-갯수nan&quot;&gt;3. 부분집합의 갯수($n(A)=n$)&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;부분집합 : $2^n$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;진부분집합 : $2^n-1$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$k$개의 특정 원소를 포함 / k개의 특정 원소를 포함하지 않음 : $2^{n-k}$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$k$개의 특정 원소 중 적어도 한 개를 포함 / $k$개의 특정 원소 중 아무것도 포함하지 않음 : $2^n-2^{n-k}$&lt;br /&gt;
 ex. $A=\{1,2,3\}$&lt;br /&gt;
 1, 2 중 적어도 한 개를 포함해야 한다고 하자. 가능한 경우는 다음과 같다.&lt;br /&gt;
 $\{1\},\{2\},\{1,2\}$&lt;br /&gt;
 $\{1,3\},\{2,3\},\{1,2,3\}$&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;4-집합의-연산&quot;&gt;4. 집합의 연산&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;$A\cup B=\{x|x\in A\;\;or\;\;x\in B \}$
    &lt;ul&gt;
      &lt;li&gt;$A\cup B=A$&lt;/li&gt;
      &lt;li&gt;$A\cup\emptyset=A$&lt;/li&gt;
      &lt;li&gt;$A\cup U=U$&lt;/li&gt;
      &lt;li&gt;$A\cup A^c=U$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$A\cap B=\{x|x\in A\;\;and\;\;x\in B \}$
    &lt;ul&gt;
      &lt;li&gt;$A\cap A=A$&lt;/li&gt;
      &lt;li&gt;$A\cap\emptyset=\emptyset$&lt;/li&gt;
      &lt;li&gt;$A\cap U=A$&lt;/li&gt;
      &lt;li&gt;$A\cap A^c=\emptyset$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$A-B=\{x|x\in A\;\;and\;\;x\notin B \}$
    &lt;ul&gt;
      &lt;li&gt;$A-B$의 다른 표현
        &lt;ul&gt;
          &lt;li&gt;$A\cap B^c$&lt;/li&gt;
          &lt;li&gt;$A-(A\cap B)$&lt;/li&gt;
          &lt;li&gt;$(A\cup B)-B$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;$A^c=\{x|x\in U\;\;and\;\;x\notin A \}$
    &lt;ul&gt;
      &lt;li&gt;$A^c=U-A$&lt;/li&gt;
      &lt;li&gt;$U^c=\emptyset$&lt;/li&gt;
      &lt;li&gt;$\emptyset^c=U$&lt;/li&gt;
      &lt;li&gt;$(A^c)^c=A$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;서로소 : $A\cap B=\emptyset$
    &lt;ul&gt;
      &lt;li&gt;서로소의 다른 표현
        &lt;ul&gt;
          &lt;li&gt;$A-B=A$&lt;/li&gt;
          &lt;li&gt;$B-A=B$&lt;/li&gt;
          &lt;li&gt;$A\subset B^c$&lt;/li&gt;
          &lt;li&gt;$B\subset A^c$&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-교환-결합-분배-법칙&quot;&gt;5. 교환, 결합, 분배 법칙&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;교환 법칙
    &lt;ul&gt;
      &lt;li&gt;$A\cap B=B\cap A$&lt;/li&gt;
      &lt;li&gt;$A\cup B=B\cup A$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;결합 법칙 : 같은 연산에 대해 괄호의 위치가 바뀌어도 성립
    &lt;ul&gt;
      &lt;li&gt;$A\cap(B\cap C)=(A\cap B)\cap C$&lt;/li&gt;
      &lt;li&gt;$A\cup(B\cup C)=(A\cup B)\cup C$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분배 법칙 : 서로 다른 연산에 적용. 역연산도 할줄 알아야 한다.
    &lt;ul&gt;
      &lt;li&gt;$A\cap(B\cup C)=(A\cap B)\cup (A\cap C)$&lt;/li&gt;
      &lt;li&gt;$A\cup(B\cap C)=(A\cup B)\cap (A\cup C)$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;드모르간 법칙
    &lt;ul&gt;
      &lt;li&gt;$(A\cap B)^c=A^c\cup B^c$&lt;/li&gt;
      &lt;li&gt;$(A\cup B)^c=A^c\cap B^c$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-집합의-원소의-갯수&quot;&gt;6. 집합의 원소의 갯수&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A\cup B)=n(A)+n(B)-n(A\cap B)$
  $n(A\cap B)=\emptyset \Rightarrow n(A\cup B)=n(A)+n(B)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A^c)=n(U)-n(A)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A-B)=n(A)-n(A\cap B)$&lt;br /&gt;
  $\qquad\qquad=n(A\cup B)-n(B)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A^c\cap B^c)=n(U)-n(A\cup B)\;\;$(드모르간 법칙 활용)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A^c\cup B^c)=n(U)-n(A\cap B)\;\;$(드모르간 법칙 활용)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A\cup B)\le n(U)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A\cap B)\le n(A) \le n(A\cup B)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;$n(A\cap B)\le n(B) \le n(A\cup B)$&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;** 마지막 세 가지는 부등호가 들어있어 최대 / 최소 문제에 많이 나옴&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">1. 정의 기준에 대해서 명화가게 구분할 수 있는 대상들의 모임 ex. 짝수의 집합, 홀수의 집합</summary></entry><entry><title type="html">03 Naive Bayes Classifier</title><link href="http://localhost:4000/posts/2020/07/28/03_naive_bayes_classifier" rel="alternate" type="text/html" title="03 Naive Bayes Classifier" /><published>2020-07-28T00:00:00-07:00</published><updated>2020-07-28T00:00:00-07:00</updated><id>http://localhost:4000/posts/2020/07/28/03_naive_bayes_classifier</id><content type="html" xml:base="http://localhost:4000/posts/2020/07/28/03_naive_bayes_classifier">&lt;h1 id=&quot;optimal-classification&quot;&gt;Optimal Classification&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/88505879-a4704a80-d013-11ea-99f7-ccfb65aec413.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;$X=x_1, x_2, …$이 주어지고, $x_i$이 $y_1$으로 분류될 확률이 $P(Y=y_1|X=x_i)$(초록색 선)이고, $y_2$으로 분류될 확률이 $P(Y=y_2|X=x_i)$(빨간색 선)이다.&lt;/p&gt;

&lt;p&gt;$x_i$가 그림의 왼쪽에 위치해 있다고 가정하자. 그렇다면 $P(Y=y_1|X=x_i)&amp;gt;P(Y=y_2|X=x_i)$이므로 $x_i$는 $y_1$으로 분류된다.&lt;/p&gt;

&lt;p&gt;마찬가지로 $x_i$가 그림의 오른쪽에 위치해 있다고 가정하자. 그렇다면 $P(Y=y_1|X=x_i)&amp;lt;P(Y=y_2|X=x_i)$이므로 $x_i$는 $y_2$으로 분류된다.&lt;/p&gt;

&lt;p&gt;이처럼 분류를 하기 위해서는 데이터($X$)가 주어졌을 때 target class에 대한 확률을 계산해야 한다.&lt;/p&gt;

&lt;h1 id=&quot;bayes-classifier&quot;&gt;Bayes Classifier&lt;/h1&gt;
&lt;p&gt;bayes classifier는 다음과 같이 정의할 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f^*=argmin_fP(f(X)\neq Y)&lt;/script&gt;

&lt;p&gt;즉, 예측치와 관측치가 같지 않을 확률을 최소화하는 $f$를 $f^*$라고 한다.&lt;/p&gt;

&lt;p&gt;두 개의 클래스를 분류하는 문제에서는 다음과 같이 표현할 수도 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f^*(x)=argmax_{Y=y}P(Y=y|X=x)&lt;/script&gt;

&lt;p&gt;$x_1$의 클래스가 $y_1$이라고 한다면 위 수식을 통해 $y_1$으로 분류될 확률을 최대화할 수 있다. 즉, $y_2$로 오분류될 확률을 최소화할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;optimal-classification-and-bayes-risk&quot;&gt;Optimal Classification and Bayes Risk&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/88509759-b99da700-d01c-11ea-8249-0a5d434b0f8b.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;위 그림에는 점선 classifier, 실선 classifier가 있다.&lt;/p&gt;

&lt;p&gt;$x_i$에서 점선 classifier의 두 확률값을 더하면 1이 된다. $x_1$이라는 입력값이 들어왔을 때, 이것을 빨간색 혹은 초록색으로 만들어줘야 하기 때문이다. 같은 논리도 $x_i$에서 실선 classifier의 두 확률값을 더해도 1이 된다. classifier가 교차하는 부분(decision boundary)에서의 확률은 0.5이다.&lt;/p&gt;

&lt;p&gt;그렇다면 점선 classifier와 실선 classifier 중 어떤 것이 더 나은 classifier일까?&lt;/p&gt;

&lt;p&gt;실선이 더 나은 classifier다.&lt;/p&gt;

&lt;p&gt;Decision boundary보다 살짝 왼쪽에 있는 $x_j$를 생각해보자. 점선 classifier는 선형이기 때문에 $x_j$가 빨간색인지 초록색인지 명확하게 구분하지 못할 가능성이 있다. 반면 실선 classifier는 점선 classifier보다는 명확하게 둘을 구분한다.&lt;/p&gt;

&lt;p&gt;실선이 더 나은 이유를 좀 더 formal하게 설명해 보겠다.&lt;/p&gt;

&lt;p&gt;위 그림에서 Decision Boundary의 왼쪽 부분을 보자. 이 부분에서도 분명히 $X$가 빨간 색으로 분류될 확률이 존재한다. 그런데 초록색으로 분류될 확률이 더 높기 때문에 이를 무시하는 것이다. 우리는 이 부분을 &lt;strong&gt;Bayes Risk&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;Bayes Risk의 측면에서 봤을 때, 점선 classifier의 risk가 실선 classifier의 risk보다 반달 모양만큼 더 크다. 그러므로 실선 classifier가 더 좋은 classifier다.&lt;/p&gt;

&lt;p&gt;우리의 목표는 작은 Bayes Risk를 가지는 classifier를 만드는 것이다.&lt;/p&gt;

&lt;h1 id=&quot;learning-the-optimal-classifier&quot;&gt;Learning the Optimal Classifier&lt;/h1&gt;
&lt;p&gt;앞서 배웠던 Optimal Classifier는 다음과 같다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f^*(x)=argmax_{Y=y}P(Y=y|X=x)&lt;/script&gt;

&lt;p&gt;이를 사전확률을 사용할 수 있는 형태로 바꾸면 다음과 같다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f^*(x)=argmax_{Y=y}P(X=x|Y=y)P(Y=y)&lt;/script&gt;

&lt;p&gt;이 경우 $P(Y=y)$는 경험적으로 알아내거나, 데이터셋에서도 알아낼 수도 있다. 데이터셋 전체에서 $y_1$는 a%, $y_2$는 (1-a)%와 같이 알아낸다.&lt;/p&gt;

&lt;p&gt;$P(X=x|Y=y)$도 conditional density를 만들 수 있다. 그런데 이 경우 문제가 되는 것은 X에 여러 개의 Random Variable이 있는 경우이다. 이 때 여러 Random Variable의 상호작용을 고려해 prediction을 해야 하는데, Random Variable의 수가 많아질수록 고려해야 할 상호작용의 수도 많아진다.&lt;/p&gt;

&lt;p&gt;이 문제를 해결해주는 것이 Naive Bayes classifier다. Naive Bayes는 Random Variable 간의 상호작용을 무시한다.&lt;/p&gt;

&lt;h1 id=&quot;dataset-for-optimal-classifier-learning&quot;&gt;Dataset for Optimal Classifier Learning&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/88513569-7c88e300-d023-11ea-9567-516b56a9dcf4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;앞서 $f^*(x)=argmax_{Y=y}P(X=x|Y=y)P(Y=y)$를 구할 때, 고려해야 할 X가 여러개 있을 때의 상황에 대한 문제를 제기를 했었다. 여기서는 그에 부합하는 데이터셋을 소개한다.&lt;/p&gt;

&lt;p&gt;$X=x_1, x_2, x_3, x_4, x_5, x_6$이며, 각각 “Sky”, “Temp”, “Humid”, “Wind”, “Water”, “Forecst”를 의미한다.&lt;/p&gt;

&lt;p&gt;$P(Y=y)$를 구하는 것은 쉽다. 데이터셋을 보면 $P(y=yes)=3/4$, $P(y=yes)=1/4$이다.&lt;/p&gt;

&lt;p&gt;반면, P(X=x|Y=y)를 구하는 것은 까다로운데, 1번 row를 대입해보면 다음과 같아진다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(x_1=sunny, x_2=warm, x_3=normal, x_4=strong, x_5=warm, x_6=same|y=yes)&lt;/script&gt;

&lt;p&gt;$x_1, x_2, …x_d$은 두 개의 값만 가지고, $Y$는 $k$개의 값을 가진다고 가정하면, $(2^d-1)k$개 만큼의 확률값을 알아야 이 문제를 해결할 수 있다.&lt;/p&gt;

&lt;p&gt;문제는 고려해야할 확률값의 수가 $X$의 수에 따라 기하급수적으로 증가한다는 점이다.&lt;/p&gt;

&lt;h1 id=&quot;conditional-independence&quot;&gt;Conditional Independence&lt;/h1&gt;
&lt;p&gt;이 문제를 해결하기 위해 도입한 것이 Conditional Independence다. 다음과 같이 정의할 수 있다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(x_1,x_2|y)=P(x_1|y)P(x_2|y)&lt;/script&gt;

&lt;p&gt;이것을 $P(X=&amp;lt; x_1, x_2, …, x_d &amp;gt;|Y=y)$에 적용시키면 $\prod_{i}^d P(X=x_i|Y=y)$으로 바뀐다.&lt;/p&gt;

&lt;p&gt;이 때 필요한 확률값의 수는 $(2-1)dk$개이다.&lt;/p&gt;

&lt;p&gt;사실 모든 입력 변수들이 서로 독립이라는 조건은 현실적이지 않다. 하지만 모델을 단순화시키고, 연산량을 줄이기 위해 마지못해 하는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;naive-bayes-classifier-function&quot;&gt;Naive Bayes Classifier Function&lt;/h3&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;f_{NB}(x)=argmax_{Y=y}P(Y=y)\prod_{1\le i \le d}P(X=x_i|Y=y)&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&quot;conditional-independence-vs-marginal-independence&quot;&gt;Conditional Independence vs Marginal Independence&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/26649034/88601092-cf59ad80-d0aa-11ea-908e-b4a37ea62058.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Commander가 지시를 내렸는데 Officer A는 그 지시를 잘 듣지 못했다. 그 상황에서 Officer B가 앞으로 전진한다면 Officer A는 지시가 무엇이었는지 잘 알지도 못한 채로 Officer B를 따라 전진할 가능성이 크다. Officer B가 가지고 있는 정보가 Officer A에게 영향을 주는 것이다. 즉, 이 둘은 독립적이지 않다.&lt;/p&gt;

&lt;p&gt;반면, Commander의 지시를 명확하게 들었다면 Officer B가 앞으로 가든, 뒤로 가든 상관 없이 들은대로 수행한다. Officer B가 가지고 있는 정보가 Officer A에게 영향을 주지 못하는 것이다. 즉, 이 둘은 독립적이다.&lt;/p&gt;

&lt;p&gt;$Y$라는 변수가 Commander이고, $X_1$, $X_2$가 각각 Officer A, B라고 해보자.&lt;/p&gt;

&lt;p&gt;$Y$에 대한 관측이 없다면, $X_2$의 정보가 $X_1$에 영향을 미친다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(X_1=Go|X_2=Go, Commander=Go)\neq P(X_1=Go, Commander=Go)&lt;/script&gt;

&lt;p&gt;반면에 $Y$에 대한 관측이 있다면, $X_2$의 정보가 $X_1$에 영향을 미치지 않는다.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P(X_1=Go|X_2=Go, Commander=Go)= P(X_1=Go, Commander=Go)&lt;/script&gt;

&lt;p&gt;즉, $Y$가 관측되었기 때문에 우리는 Conditional Independence를 정의할 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;problems-of-naive-bayes-classifier&quot;&gt;Problems of Naive Bayes Classifier&lt;/h1&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Naive Assumption
변수들이 conditionally independence하다는 가정 자체가 현실적이지 않음.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Incorrect Probability Estimation
압정을 세 번 던져서 모두 앞면이 나왔다면, 뒤면이 나올 확률은 분명히 존재함에도 $P(뒷면)=0$이 된다(MLE).&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;avatar&quot;=&gt;nil, &quot;bio&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;employer&quot;=&gt;nil, &quot;pubmed&quot;=&gt;nil, &quot;googlescholar&quot;=&gt;nil, &quot;email&quot;=&gt;&quot;blanik00@gmail.com&quot;, &quot;researchgate&quot;=&gt;nil, &quot;uri&quot;=&gt;nil, &quot;bitbucket&quot;=&gt;nil, &quot;codepen&quot;=&gt;nil, &quot;dribbble&quot;=&gt;nil, &quot;flickr&quot;=&gt;nil, &quot;facebook&quot;=&gt;nil, &quot;foursquare&quot;=&gt;nil, &quot;github&quot;=&gt;nil, &quot;google_plus&quot;=&gt;nil, &quot;keybase&quot;=&gt;nil, &quot;instagram&quot;=&gt;nil, &quot;impactstory&quot;=&gt;nil, &quot;lastfm&quot;=&gt;nil, &quot;linkedin&quot;=&gt;nil, &quot;orcid&quot;=&gt;nil, &quot;pinterest&quot;=&gt;nil, &quot;soundcloud&quot;=&gt;nil, &quot;stackoverflow&quot;=&gt;nil, &quot;steam&quot;=&gt;nil, &quot;tumblr&quot;=&gt;nil, &quot;twitter&quot;=&gt;nil, &quot;vine&quot;=&gt;nil, &quot;weibo&quot;=&gt;nil, &quot;xing&quot;=&gt;nil, &quot;youtube&quot;=&gt;nil, &quot;wikipedia&quot;=&gt;nil}</name><email>blanik00@gmail.com</email></author><category term="[&quot;posts&quot;]" /><summary type="html">Optimal Classification</summary></entry></feed>